# RAG Architecture Documentation

## Overview
InsightSim's RAG (Retrieval Augmented Generation) system enhances AI persona responses by providing relevant context from uploaded documents. This document outlines the complete architecture, data flow, and implementation details.

## System Architecture

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Frontend      │    │   Next.js API   │    │  Python RAG     │
│   (React/Next)  │────│   Routes        │────│  Service        │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         │              ┌─────────────────┐              │
         │              │   Supabase      │              │
         └──────────────│   Database +    │──────────────┘
                        │   Storage       │
                        └─────────────────┘
```

## Technology Stack

### Frontend
- **Next.js 14**: React framework with App Router
- **TypeScript**: Type safety and better DX
- **Tailwind CSS**: Styling and responsive design

### Backend
- **Python FastAPI**: Async web framework for RAG service
- **LlamaIndex**: Document processing and RAG orchestration
- **OpenAI Embeddings**: text-embedding-ada-002 model

### Database & Storage
- **Supabase PostgreSQL**: Primary database with pgvector extension
- **Supabase Storage**: File storage for uploaded documents
- **pgvector**: Vector similarity search for embeddings

## Data Flow

### Document Upload Flow
1. **User uploads file** via React drag-and-drop interface
2. **Frontend validates** file type and size
3. **Next.js API route** uploads file to Supabase Storage
4. **Database record created** in `rag_documents` table with `processing` status
5. **Python service called** asynchronously for document processing
6. **LlamaIndex processes** document (chunking + embedding)
7. **Vectors stored** in pgvector with metadata
8. **Status updated** to `completed` or `failed`

### RAG Query Flow
1. **User sends message** in simulation
2. **System checks** if RAG enabled for simulation
3. **Query sent** to Python RAG service for context retrieval
4. **Vector similarity search** finds relevant document chunks
5. **Context injected** into LLM prompt
6. **Enhanced response** generated by AI persona

## Component Architecture

### Frontend Components
```
components/
├── rag-upload-modal.tsx      # File upload interface
├── rag-document-list.tsx     # Document management
├── rag-toggle.tsx            # Enable/disable RAG
└── rag-status-indicator.tsx  # Processing status display
```

### Backend Services
```
python-rag-service/
├── app/
│   ├── main.py                 # FastAPI application
│   ├── services/
│   │   └── rag_service.py     # LlamaIndex integration
│   ├── routes/
│   │   ├── upload.py          # Document processing
│   │   └── retrieve.py        # Context retrieval
│   └── models/
│       └── schemas.py         # Pydantic models
```

### API Routes
```
Next.js API Routes:
├── /api/rag/upload           # File upload to storage
├── /api/rag/documents        # List user documents
├── /api/rag/delete          # Delete document
└── /api/rag/settings        # RAG configuration

Python FastAPI:
├── /process-document         # Async document processing
├── /retrieve-context         # Get relevant chunks
├── /document/{id}/status     # Processing status
└── /health                   # Service health check
```

## Database Schema

### Core Tables
- **`rag_documents`**: Document metadata and processing status
- **`simulation_rag_settings`**: Per-simulation RAG configuration
- **`vecs_*`**: LlamaIndex-managed vector tables (auto-created)

### Relationships
```
simulations (1) ──── (n) rag_documents
simulations (1) ──── (1) simulation_rag_settings
users (1) ──── (n) rag_documents
```

## Security Model

### Multi-Layer Security
1. **Authentication**: Supabase Auth for user identity
2. **Row Level Security**: Database-level access control
3. **Storage Policies**: File access restrictions
4. **API Validation**: Input sanitization and validation

### Access Control
- Users can only access their own documents
- Documents are isolated per simulation
- File paths include user ID for additional security
- RLS policies enforce access at database level

## Configuration

### Environment Variables
```bash
# Supabase
SUPABASE_URL=your_supabase_url
SUPABASE_SERVICE_KEY=your_service_key
DATABASE_URL=your_database_connection_string

# OpenAI
OPENAI_API_KEY=your_openai_key

# Python Service
PYTHON_RAG_SERVICE_URL=http://localhost:8000
```

### RAG Parameters
- **Chunk Size**: 500 tokens (configurable per simulation)
- **Chunk Overlap**: 50 tokens (prevents context loss)
- **Embedding Model**: text-embedding-ada-002 (1536 dimensions)
- **Similarity Top-K**: 3 most relevant chunks
- **Max File Size**: 50MB

## Performance Considerations

### Optimization Strategies
1. **Async Processing**: Background document processing
2. **Connection Pooling**: Database connection management
3. **Caching**: Vector embeddings cached in database
4. **Batch Processing**: Multiple documents processed together

### Scalability
- **Horizontal**: Multiple Python service instances
- **Vertical**: Larger database and compute resources
- **Caching**: Redis for frequently accessed vectors
- **CDN**: Static file serving optimization

## Monitoring & Observability

### Metrics to Track
- Document processing success/failure rates
- Vector similarity search performance
- API response times
- Storage usage per user/simulation
- Embedding generation costs

### Logging
- Document processing events
- RAG query performance
- Error tracking and alerting
- User activity analytics

## Error Handling

### Graceful Degradation
- RAG failures don't break simulation flow
- Fallback to non-RAG responses when service unavailable
- Retry logic for transient failures
- User feedback for processing errors

### Error Types
- **Upload Errors**: File type, size, network issues
- **Processing Errors**: Corrupted files, embedding failures
- **Query Errors**: Vector search failures, timeout issues
- **Storage Errors**: Insufficient space, permission issues

## Phase 2: PDF Support

### Additional Components
- **PDF Text Extraction**: PyPDF2 or pdfplumber
- **Table Detection**: camelot-py for structured data
- **OCR Processing**: pytesseract for image text
- **Smart Parsing**: Advanced document structure recognition

### Enhanced Processing Pipeline
1. **Multi-format Detection**: Automatic file type handling
2. **Structure Preservation**: Maintain document hierarchy
3. **Table Extraction**: Convert tables to structured text
4. **Image Processing**: OCR for embedded images
5. **Metadata Extraction**: Document properties and structure

## Best Practices

### Development
- Use TypeScript for type safety
- Implement comprehensive error handling
- Write unit tests for critical components
- Document API endpoints thoroughly

### Deployment
- Use environment-specific configurations
- Implement health checks for all services
- Monitor resource usage and costs
- Set up automated backups

### Security
- Validate all user inputs
- Use prepared statements for database queries
- Implement rate limiting on API endpoints
- Regular security audits and updates

## Troubleshooting

### Common Issues
1. **Document Processing Stuck**: Check Python service logs
2. **Vector Search Slow**: Optimize chunk size and indexing
3. **High Embedding Costs**: Monitor API usage and implement caching
4. **Storage Quota Exceeded**: Implement cleanup policies

### Debug Commands
```bash
# Check vector table size
SELECT count(*) FROM vecs_simulation_123;

# Monitor processing status
SELECT processing_status, count(*) FROM rag_documents GROUP BY processing_status;

# Check storage usage
SELECT sum(file_size) FROM rag_documents WHERE user_id = 'user_id';
```

## Future Enhancements

### Planned Features
- **Multi-language Support**: International document processing
- **Advanced Analytics**: RAG usage and effectiveness metrics
- **Collaborative RAG**: Shared document libraries
- **AI-Powered Summarization**: Automatic document insights

### Integration Opportunities
- **External Data Sources**: API-based document ingestion
- **Real-time Updates**: Live document synchronization
- **Advanced Search**: Semantic search across all documents
- **Export Capabilities**: RAG-enhanced report generation 